---
title: "clustering-code-R"
---

# Libraries

```{r}
#| warning: false
library(tidymodels)
library(tidyverse)
library(tidyclust)
library(rio)
library(GGally)
library(plotly)
library(cluster)
library(factoextra)
library(NbClust)
```


# Base de Datos: Customer Personality Analysis

## Contenido
Base de datos de **perfiles de clientes** con información demográfica, histórico de compras, interacciones con campañas de marketing y patrones de comportamiento.

## Variables originales
- Datos demográficos (edad, educación, ingresos, estado civil)
- Gasto por categoría de producto (vinos, frutas, carnes, pescado, dulces, oro)
- Canales de compra (web, catálogo, tienda física)
- Respuesta a campañas de marketing
- Recencia de compras e interacciones

## Variables seleccionadas para la práctica
- **Gasto total:** Suma de todas las categorías de productos
- **Cantidad de compra total:** Suma de todas las transacciones
- **Edad:** Derivada del año de nacimiento


# Importacion y tratamiento de la data

```{r}
data <- import("marketing_campaign.csv")
```

```{r}
str(data)
```

Exploramos las variables categoricas:

```{r}
data$Education |> n_distinct()
data$Marital_Status |>  n_distinct()
data$Dt_Customer |> n_distinct()

```

```{r}
data$Education |> table()
```

```{r}
data$Marital_Status |> table()
```

```{r}
data$Dt_Customer |> table()
```

Transformamos las variables

-   Calculamos la edad

```{r}
data <- data |> 
  mutate(Edad = 2021 - Year_Birth)
```

-   Gasto total

```{r}
data <- data |> 
  mutate(Gasto_total = MntWines + MntFruits + MntMeatProducts + MntFishProducts + MntSweetProducts + MntGoldProds)
```

-   Estado civil

```{r}
data <- data |> 
  mutate(estado_civil = case_when(
    Marital_Status %in% c("Married", "Together") ~ "Casado",
    Marital_Status %in% c("Absurd", "Widow", "YOLO", "Divorced", "Single") ~ "Soltero",
    TRUE ~ Marital_Status
  ))
```

-   Cantidad de hijos

```{r}
data <- data |> 
  mutate(Cantidad_hijos = Kidhome + Teenhome)
```

-   Tamaño de la familia

```{r}
data <- data |> 
  mutate(Tamaño_Familia = case_when(
    estado_civil == "Soltero" ~ 1 + Cantidad_hijos,
    estado_civil == "Casado" ~ 2 + Cantidad_hijos
  ))
```

-   Padre de familia

```{r}
data <- data |> 
  mutate(Padre_de_Familia = ifelse(Cantidad_hijos > 0, 1, 0))
```

-   Educacion

```{r}
data <- data |> 
  mutate(Educacion = case_when(
    Education %in% c("Basic", "2n Cycle") ~ "básica",
    Education == "Graduation" ~ "Pre_grado",
    Education %in% c("Master", "PhD") ~ "Pos_grado",
    TRUE ~ Education
  ))
```

-   Cambio de nombre a columnas de interes

```{r}
data <- data |> 
  rename(
    Vinos = MntWines,
    Frutas = MntFruits,
    Carne = MntMeatProducts,
    Pescado = MntFishProducts,
    Dulces = MntSweetProducts,
    Gold = MntGoldProds,
    Ingreso = Income,
    Niño_en_casa = Kidhome,
    Adolecente_en_casa = Teenhome,
    Dias_ultima_compra = Recency,
    gasto_vinos = MntWines,
    gasto_frutas = MntFruits,
    gasto_carne = MntMeatProducts,
    gasto_pescado = MntFishProducts,
    gasto_dulces = MntSweetProducts,
    gasto_gold = MntGoldProds,
    cantidad_compra_con_descuento = NumDealsPurchases,
    cantidad_compra_web = NumWebPurchases,
    cantidad_compra_catalogo = NumCatalogPurchases,
    cantidad_compra_tienda = NumStorePurchases, 
    cantidad_visitas_web_mes = NumWebVisitsMonth, 
    acepto_campaña_1 = AcceptedCmp1,
    acepto_campaña_2 = AcceptedCmp2,
    acepto_campaña_3 = AcceptedCmp3,
    acepto_campaña_4 = AcceptedCmp4,
    acepto_campaña_5 = AcceptedCmp5,
    registra_quejas = Complain,
    respondio_a_campaña = Response
    
  )
```

-   Variables descartadas

```{r}
data <- data |> 
  select(-c(Marital_Status, Dt_Customer, Z_CostContact, Z_Revenue, Year_Birth, ID, Education))
```

```{r}
data
```

## Buscamos valores faltantes y duplicados

```{r}
na_dup <- function(data) {
  missing_values <- colSums(is.na(data))
  missing_values_perc <- missing_values / nrow(data) * 100
  duplicated_values <- sum(duplicated(data))
  duplicated_values_perc <- duplicated_values / nrow(data) * 100
  data_types <- sapply(data, class)
  
  resumen <- data.frame(
    Valores_Faltantes  = missing_values,
    Valores_Faltantes_Porcentaje = missing_values_perc,
    Valores_Duplicados = duplicated_values,
    Valores_Duplicados_Porcentaje = duplicated_values_perc,
    Tipo_de_Variable = data_types,
    stringsAsFactors = FALSE
  )
  
  return(resumen)
}

na_dup(data)
```

-   No se identificaron valores duplicados
-   Se identificó que la columna **Ingreso** tiene valores faltantes, por lo cual se procesera a la imputacion de los datos

```{r}
data <- data |>
        mutate(Ingreso = replace(Ingreso, is.na(Ingreso), mean(Ingreso, na.rm = TRUE)))

```

Verificamos que no haya datos faltantes

```{r}
na_dup(data)
```

-   Los valores faltantes fueron imputados correctamente

## convertimos a factores

```{r}
char_a_factores <- function(data) {
  data <- data |> 
    mutate(across(where(is.character), as.factor))
  return(data)
}

data <- char_a_factores(data)
str(data)

```

## deteccion de posibles outliers en la data

```{r}
detectar_outliers <- function(x, nombre_var = "") {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  
  limite_inferior <- Q1 - 1.5 * IQR
  limite_superior <- Q3 + 1.5 * IQR
  
  outliers <- x < limite_inferior | x > limite_superior
  
  boxplot(x, main = paste("Boxplot de", nombre_var), 
          ylab = "Valor", col = "orange") 

  return(list(
    outliers = which(outliers),
    cantidad = sum(outliers),
    limites = c(inferior = limite_inferior, superior = limite_superior)
  ))
}
```

-   Variables con posibles ouliers

    -   Ingreso

```{r}
detectar_outliers(data$Ingreso, "Ingreso")
```

```         
- Edad
```

```{r}
detectar_outliers(data$Edad, "Edad")
```

```         
- gasto_vinos
```

```{r}
detectar_outliers(data$gasto_vinos, "Gasto en Vinos")
```

```         
- gasto_frutas
```

```{r}
detectar_outliers(data$gasto_frutas, "Gasto en Frutas")
```

```         
- gasto_carne
```

```{r}
detectar_outliers(data$gasto_carne, "Gasto en Carne")
```

```         
- gasto_pescado
```

```{r}
detectar_outliers(data$gasto_pescado, "Gasto en Pescado")
```

```         
- gasto_dulces
```

```{r}
detectar_outliers(data$gasto_dulces, "Gasto en Dulces")
```

```         
- gasto_gold
```

```{r}
detectar_outliers(data$gasto_gold, "Gasto en Gold")
```

```         
- gasto_total
```

```{r}
detectar_outliers(data$Gasto_total, "Gasto Total")
```

```         
- Dias_ultima_compra 
```

```{r}
detectar_outliers(data$Dias_ultima_compra, "Dias desde la última compra")
```

```         
- cantidad_compra_con_descuento
```

```{r}
detectar_outliers(data$cantidad_compra_con_descuento, "Cantidad de compra con descuento")
```

```         
- cantidad_compra_web   
```

```{r}
detectar_outliers(data$cantidad_compra_web, "Cantidad compra web")
```

```         
- cantidad_compra_catalogo
```

```{r}
detectar_outliers(data$cantidad_compra_catalogo, "Cantidad compra catalogo")
```

```         
- cantidad_compra_tienda 
```

```{r}
detectar_outliers(data$cantidad_compra_tienda, "Cantidad compra en tienda")
```

```         
- cantidad_visitas_web_mes 
```

```{r}
detectar_outliers(data$cantidad_visitas_web_mes, "Cantidad de visitas web al mes")
```

```{r}

```

## Datos seleccionados

Luego de revisar los datos, para los objetivos de la practica se seleccionaron las siguientes variables

-   Gasto total
-   Cantidad Compra total (suma de las variables cantidad compra)
-   Edad

```{r}
data <- data |> 
  mutate(Cantidad_compra_total = cantidad_compra_con_descuento + 
                                 cantidad_compra_web + 
                                 cantidad_compra_catalogo + 
                                 cantidad_compra_tienda) |>
  select(Gasto_total, Edad, Cantidad_compra_total)
```

## Eliminamos outliers

```{r}
eliminar_outliers <- function(data) {
  for (col in colnames(data)) {
    Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
    Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
    IQR <- Q3 - Q1
    
    data <- data |> 
      filter(data[[col]] >= Q1 - 1.5 * IQR & data[[col]] <= Q3 + 1.5 * IQR)
  }
  return(data)
}


data <- eliminar_outliers(data)
```

### Comprovamos si quedan outliers

```{r}
detectar_outliers(data$Gasto_total, "Gasto total")
detectar_outliers(data$Edad, "Edad")
detectar_outliers(data$Cantidad_compra_total, "Cantida Compra Total")
```

# Análisis exploratorio de datos

```{r}
data |>  
  ggplot(aes(x= Gasto_total, y=Cantidad_compra_total)) + 
  geom_point() 
```

```{r}
data |>  
  ggplot(aes(x= Gasto_total, y=Edad)) + 
  geom_point() 
```

```{r}
plot_ly(x = data$Gasto_total,
        y = data$Cantidad_compra_total,
        z = data$Edad,
        text = rownames(data),
        type = "scatter3d",
        mode = "markers") |> 
  layout(
    scene = list(
      xaxis = list(title = "Gasto total"),
      yaxis = list(title = "Cantidad de Compra Total"),
      zaxis = list(title = "Edad")
    )
  )
```

# Calculamos las distancias

```{r}
distancias= daisy(data, 
                  metric="gower")
```

# Determinamos el número de clusters

## Método del codo (elbow method)

```{r}
fviz_nbclust(data, 
             hcut,                    
             diss=distancias,        
             method = "wss",         
             k.max = 10,            
             verbose = F)
```

-   Escogemos **3 clusters**

## Método NbClust

```{r}
set.seed(2025)
res.nbclust <- NbClust(data,           
                       distance = "euclidean",  
                       min.nc = 2,              
                       max.nc = 5,              
                       method = "average",      
                       index ="all")          
```

-   Confirmamos que tenemos que usar **3 clusters**

# Calculamos el cluster

## Jerarquico Aglomerativo

```{r}
aglomerativo = hcut(x = distancias,       
                    k = 3,               
                    hc_func='agnes',      
                    hc_method = "ward.D") 
```

### Dendograma de Cluster Jerarquico Aglomerativo

```{r}
fviz_dend(aglomerativo, 
          rect = TRUE,  
          cex = 0.5)    
```

```{r}
data2<-data %>% 
  mutate(aglomerativo=aglomerativo$cluster) 

data2 %>% 
  group_by(aglomerativo) %>% 
  summarise(Gasto_total = mean(Gasto_total),
            Edad = mean(Edad), 
            Cantidad_compra_total = mean(Cantidad_compra_total))
```

Podemos ver que:

-   Cluster 1: Presenta, en promedio, los mayores niveles de gasto total (\$1,355.83), la mayor cantidad de compras (23.01) y una edad moderada (51.81 años). Son clientes de alto valor con comportamiento de compra muy activo.

-   Cluster 2: Presenta, en promedio, los menores niveles de gasto total (\$89.71), la menor cantidad de compras (7.54) y una edad similar a los otros grupos (48.93 años). Son clientes de bajo valor con comportamiento de compra muy limitado.

-   Cluster 3: Presenta, en promedio, niveles intermedios de gasto total (\$626.83) y cantidad de compras (17.94), pero destaca por tener la mayor edad promedio (57.71 años). Son clientes de valor moderado con comportamiento de compra regular y perfil más maduro.

```{r}
fviz_cluster(object = list(data=data2[,1:3], 
                           cluster = data2$aglomerativo),
             geom = c("text"), 
             ellipse.type = "convex")
```

### Validacion del cluster

```{r}
plot_con <- fviz_silhouette(aglomerativo, label=TRUE)
plot_con
```

El ancho promedio de silueta de 0.35 indica una calidad de clustering moderada y aceptable. El Cluster 2 (verde) es el más compacto y bien definido con excelente cohesión, mientras que el Cluster 1 (rojo) presenta baja cohesión con elementos mal clasificados y el Cluster 3 (azul) muestra cohesión moderada con cierta dispersión. En general, el clustering es satisfactorio, aunque los Clusters 1 y 3 presentan debilidades que podrían mejorarse.

## Divisivo

```{r}
divisivo = hcut(distancias, 
                k = 3,           
                hc_func='diana')
```

### Dendograma de Divisivo

```{r}
fviz_dend(divisivo, 
          rect = TRUE, 
          cex = 0.5)
```

```{r}
data3<-data %>% 
  mutate(divisivo=divisivo$cluster) 

data3 %>% 
  group_by(divisivo) %>% 
  summarise(Gasto_total = mean(Gasto_total),
            Edad = mean(Edad), 
            Cantidad_compra_total = mean(Cantidad_compra_total))
```

Podemos ver que:

-   Cluster 1 (Divisivo): Presenta, en promedio, altos niveles de gasto total (\$1,094.53), la mayor edad promedio (64.45 años) y alto número de compras (21.60). Son clientes de valor alto con perfil maduro.

-   Cluster 2 (Divisivo): Presenta, en promedio, los menores niveles de gasto total (\$146.84), la menor edad promedio (50.18 años) y el menor número de compras (9.19). Son clientes de bajo valor con comportamiento ocasional.

-   Cluster 3 (Divisivo): Presenta, en promedio, el mayor gasto total (\$1,238.08), la menor edad promedio (44.34 años) y el mayor número de compras (22.03). Son clientes de valor muy alto, más jóvenes y con comportamiento de compra muy activo.

```{r}
fviz_cluster(object = list(data=data3[,1:3], 
                           cluster = data3$divisivo),
             geom = c("text"), 
             ellipse.type = "convex")
```

### Validacion de Cluster

```{r}

plot_div <- fviz_silhouette(divisivo, label=TRUE)
plot_div
```

El ancho promedio de silueta de 0.42 indica una calidad de clustering buena. El Cluster 2 (verde) mantiene su excelente cohesión con valores de silueta altos, el Cluster 1 (rojo) muestra mejor definición con valores cercanos al promedio, y el Cluster 3 (azul) presenta cohesión moderada. Sin embargo, el Cluster 2 presenta algunos puntos con valores negativos de silueta, indicando elementos mal clasificados o fronterizos que podrían pertenecer mejor a otros clusters.

# Conclusiones

```{r}
plot_con
plot_div
```

El modelo divisivo con ancho de silueta 0.42 tiene mejor desempeño que el modelo jerárquico aglomerativo con 0.35. El clustering divisivo logra una calidad superior con mayor separación entre clusters y menos elementos mal clasificados. Este modelo identifica tres segmentos de clientes claramente diferenciados: el Cluster 3 representa el segmento más valioso con mayor gasto y frecuencia de compra, el Cluster 1 agrupa clientes maduros de alto valor, y el Cluster 2 clientes ocasionales de bajo valor. Esta segmentación permite implementar estrategias de marketing personalizadas: retención y premium para Clusters 1 y 3, y activación para Cluster 2.
